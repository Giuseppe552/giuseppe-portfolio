name: zap-baseline
on:
  workflow_dispatch:
  push:
    branches: [ main ]
  pull_request:

concurrency:
  group: zap-${{ github.ref }}
  cancel-in-progress: true

jobs:
  zap:
    runs-on: ubuntu-latest
    concurrency:
      group: zap-${{ github.ref }}
      cancel-in-progress: true
    permissions:
      contents: read
      pull-requests: write
    steps:
      - uses: actions/checkout@v4
      
      - name: Detect target URL
        id: target
        run: |
          # Try to detect PR Preview URL from Vercel deployments
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            # For now, fallback to production URL since we don't have Vercel token access
            # In future, could parse PR timeline for deployment status
            echo "target_url=https://giuseppegiona.com" >> $GITHUB_OUTPUT
          else
            echo "target_url=https://giuseppegiona.com" >> $GITHUB_OUTPUT
          fi
          
      - name: Check target availability
        id: precheck
        continue-on-error: true
        run: |
          target_url="${{ steps.target.outputs.target_url }}"
          echo "Checking availability of: $target_url"
          
          status_code=$(curl -o /dev/null -s -w "%{http_code}" --max-time 30 "$target_url" || echo "000")
          echo "HTTP status: $status_code"
          
          if [[ "$status_code" =~ ^[23][0-9][0-9]$ ]]; then
            echo "available=true" >> $GITHUB_OUTPUT
            echo "status_code=$status_code" >> $GITHUB_OUTPUT
          else
            echo "available=false" >> $GITHUB_OUTPUT  
            echo "status_code=$status_code" >> $GITHUB_OUTPUT
          fi
          
      - name: Comment on PR if target unavailable
        if: github.event_name == 'pull_request' && steps.precheck.outputs.available == 'false'
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: `### ZAP Scan Skipped
              
              Target not reachable: ${{ steps.target.outputs.target_url }}
              HTTP code: ${{ steps.precheck.outputs.status_code }}
              
              The security scan was skipped because the target URL is not responding.`
            });
            
      - name: Run ZAP Baseline Scan
        if: steps.precheck.outputs.available == 'true'
        uses: zaproxy/action-baseline@v0.11.0
        with:
          target: ${{ steps.target.outputs.target_url }}
          cmd_options: "-a -T 120"
        continue-on-error: true
          
      - name: Upload ZAP report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: zap-report
          path: report_html.html
          
      - name: Parse ZAP results and comment
        if: always() && github.event_name == 'pull_request'
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            let summary = '### ZAP Security Scan Results\n\n';
            
            try {
              if (!fs.existsSync('report_html.html')) {
                summary += '‚ö†Ô∏è **Scan Status:** Report file not found - scan may have been skipped or failed\n\n';
                summary += `**Target:** ${{ steps.target.outputs.target_url || 'N/A' }}\n\n`;
              } else {
                // Parse the HTML report for alert counts
                const reportContent = fs.readFileSync('report_html.html', 'utf8');
                
                // Extract alert counts using more robust regex patterns
                const highMatch = reportContent.match(/High.*?(\d+)/i) || reportContent.match(/(\d+).*?High/i);
                const mediumMatch = reportContent.match(/Medium.*?(\d+)/i) || reportContent.match(/(\d+).*?Medium/i);  
                const lowMatch = reportContent.match(/Low.*?(\d+)/i) || reportContent.match(/(\d+).*?Low/i);
                const infoMatch = reportContent.match(/Informational.*?(\d+)/i) || reportContent.match(/(\d+).*?Informational/i);
                
                summary += `‚úÖ **Scan Status:** Completed successfully\n\n`;
                summary += `**Target:** ${{ steps.target.outputs.target_url }}\n\n`;
                summary += `**Alert Summary:**\n`;
                summary += `- üî¥ High: ${highMatch ? highMatch[1] : '0'}\n`;
                summary += `- üü† Medium: ${mediumMatch ? mediumMatch[1] : '0'}\n`;  
                summary += `- üü° Low: ${lowMatch ? lowMatch[1] : '0'}\n`;
                summary += `- ‚ÑπÔ∏è Informational: ${infoMatch ? infoMatch[1] : '0'}\n\n`;
              }
              
            } catch (err) {
              console.log('Error parsing report:', err.message);
              summary += '‚ö†Ô∏è **Scan Status:** Completed but report parsing failed\n\n';
              summary += `**Target:** ${{ steps.target.outputs.target_url || 'N/A' }}\n\n`;
              summary += `**Error:** ${err.message}\n\n`;
            }
            
            summary += '_Full HTML report available in artifacts: **zap-report**_';
            
            try {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: summary
              });
              console.log('Successfully posted ZAP results comment');
            } catch (commentErr) {
              console.log('Failed to post comment:', commentErr.message);
            }
            
            // Always exit successfully regardless of parsing or comment failures
            process.exit(0);
